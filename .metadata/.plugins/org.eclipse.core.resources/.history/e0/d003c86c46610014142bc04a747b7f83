import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collections;

/**
 * A benchmark to identify the amount of time required to sort various arrays
 * based upon the type of sorting method, including selection sort, merge sort
 * and quick sort
 * @author Jason Yao
 */
public class SortAlgorithmBenchmarking {

	/**
	 * The main method of the SortAlgorithmBenchmarking Class that runs each benchmark
	 */
	public static void main(String[] args)
	{	
		// Generates a pseudo-random array of doubles
		// NOTE: As generics can't deal with primitives, we use Double instead
		Double[] inputArray = new Double[10];

		// Populating the array
		for (int i = 0; i < inputArray.length; ++i)
		{inputArray[i] = Math.random();}

		// ---------- START OF THE SELECTION SORT ----------
		// Finds the start of the selectionSortTimer
		long selectionSortStartTime = System.nanoTime();

		// Sorts the array via Selection Sort
		Double[] selectionSortedArray = ArraySortTools.selectionSort(inputArray);

		// Finds the end of the selectionSortTimer
		long selectionSortEndTime = System.nanoTime();

		// Finds the total selectionSortRunTime in milliseconds
		double selectionSortRunTime = ((double)(selectionSortEndTime - selectionSortStartTime)/ (double) 1000000);
		// ---------- END OF THE SELECTION SORT ----------

		// FOR TESTING ONLY
		//		System.out.println("The final state of the selection-sorted array is:");
		//		for (int i = 0; i < selectionSortedArray.length; ++i)
		//		{System.out.println(selectionSortedArray[i]);}
		System.out.println("The selection sort took : " + selectionSortRunTime + " milliseconds");

		// ---------- START OF THE MERGE SORT ----------
		// Finds the start of the mergeSortTimer
		long mergeSortStartTime = System.nanoTime();

		// Sorts the array via Merge Sort
		Double[] mergeSortedArray = ArraySortTools.mergeSort(inputArray);

		// Finds the end of the mergeSortTimer
		long mergeSortEndTime = System.nanoTime();

		// Finds the total mergeSortRunTime in milliseconds
		double mergeSortRunTime = ((double)(mergeSortEndTime - mergeSortStartTime)/ (double) 1000000);
		// ---------- END OF THE MERGE SORT ---------

		System.out.println("The merge sort took : " + mergeSortRunTime + " milliseconds");

		// Sorts the array via Merge Sort
		//Double[] mergeSortedArray = mergeSort(inputArray);

		// FOR TESTING ONLY
		System.out.println("The final state of the merge-sorted array is:");
		for (int i = 0; i < mergeSortedArray.length; ++i)
		{System.out.println(mergeSortedArray[i]);}

		// ---------- START OF THE QUICK SORT ----------



		// ---------- END OF THE QUICK SORT ----------



		// ---------- START OF TESTING MERGE METHOD ----------
		Double[] testArray = new Double[10];
		for (int i = 0; i < testArray.length; ++i)
		{testArray[i] = Math.random();}

		Double[] testArray2 = new Double[10];
		for (int i = 0; i < testArray2.length; ++i)
		{testArray2[i] = Math.random();}

		Arrays.sort(testArray);
		Arrays.sort(testArray2);

		Double [] finalTestArray = new Double[20];
		for (int i = 0; i < testArray.length; ++i)
		{finalTestArray[i] = testArray[i];}
		for (int i = 0; i < testArray2.length; ++i)
		{
			finalTestArray[i + 10] = testArray2[i];
		}

		ArraySortTools.mergeTest(finalTestArray, 0, 9, 10, 19);

		System.out.println("The final state for the merged array is:");
		for (int i = 0; i < finalTestArray.length; ++i)
		{
			System.out.println(finalTestArray[i]);
		}





















		// END OF TESTING MERGE METHOD ----------

















		// Sorts the array via Quick Sort


		//		// For testing only: prints out the array
		//		for (int i = 0; i < inputArray.length; ++i)
		//		{
		//			System.out.println(inputArray[i]);
		//		}

	} // End of main method


} // End of benchmarking class
