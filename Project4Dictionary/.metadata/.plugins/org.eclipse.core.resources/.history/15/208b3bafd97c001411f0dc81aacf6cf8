import java.util.ArrayList;

/**
 * 
 */

/**
 * @author Jason
 *
 */
public class CollectionOfLetters
{
	// Global Attributes
	private ArrayList<Character> lettersInArray;

	//stores reference to a dictionary to avoid passing it
	//between recursive calls.
	private Dictionary dict; 

	public CollectionOfLetters(String sanitizedUserInput)
	{
		lettersInArray = new ArrayList<Character>();
		// Finds the permutations for an n-length string
		for (int i = 0; i < sanitizedUserInput.length(); i++)
			lettersInArray.add(sanitizedUserInput.charAt(i));
	} // End of the CollectionOfLetters constructor

	/**
	 * Constructs all words from the letters in the current object that are 
	 * listed in the given dictionary. 
	 * @param dict  the dictionary to use in the search
	 * @return  ArrayList object containing all possible words, or null if either
	 * passed dictionary is null, or there are no words that can be created. 
	 */
	public ArrayList<String> getAllWords (Dictionary dict) {
		if ( null == dict ) return null;

		this.dict = dict;
		ArrayList<String> words = new ArrayList<String> ();
		StringBuffer prefix = new StringBuffer ();
		getAllWordsRecursive ( lettersInArray, prefix, words );
		cleanUpResults(words);


		return words;
	}

	/*
	 * Actual recursive method (using backtracking) that constructs the words. 
	 * @param possibleLetters  remaining letters that can be added to the prefix
	 * @param prefix  prefix constructed so far
	 * @param words   collection of completed words that have been already discovered 
	 */
	private void getAllWordsRecursive ( 
			ArrayList<Character> possibleLetters, 
			StringBuffer prefix,
			ArrayList<String> words
			) 
	{
		//System.out.println(prefix);

		if (possibleLetters.size() == 0) {
			words.add(prefix.toString());
			//prefix.deleteCharAt(prefix.length()-1);
		}
		else
			for (int i = 0; i < possibleLetters.size(); i++ ) {

				prefix.append(possibleLetters.get(i));

				if ( dict.isWordInDictionary( prefix.toString()  ) ) {
					words.add(prefix.toString());
				}

				//System.out.println(prefix.toString());
				if ( dict.isPrefixInDictionary(prefix.toString() ) ) {
					ArrayList <Character> remainingLetters = new ArrayList<Character> (possibleLetters);
					remainingLetters.remove(i);
					getAllWordsRecursive( remainingLetters, prefix, words );
					prefix.deleteCharAt(prefix.length()-1);

				}
				else {
					prefix.deleteCharAt(prefix.length()-1);
				}
			}
	}

	/* 
	 * Cleans up the results computed by getAllWordsRecursive by sorting
	 * them and removing all repeated words.
	 * @param words  collection of words computed by getAllWordsRecursive
	 */
	private void cleanUpResults(ArrayList<String> words) {
		// sort the results 
		Collections.sort(words);
		//remove duplicates
		int i = 1;
		while (i < words.size()) {
			if (words.get(i).equals(words.get(i - 1)))
				words.remove(i);
			else
				i++;
		}

	}








	/**
	 * Alters the permutations global attribute to be filled with all possible permutations of the characters entered by the user
	 * @param prefix Initially an empty string, but changes to be one of the first characters in the String
	 * @param wordInput The sanitized user input, which is subsequently changed with each recursive call
	 * @param index The index of the position to be filled by a permutation in the permutations global attribute
	 */
	private void findPermutations(String prefix, String wordInput, int index)
	{
		// Base case
		if (wordInput.length() <= 1)
		{this.permutations.add(prefix + wordInput);}

		// Recursive case
		else
		{
			for (int i = 0; i < wordInput.length(); ++i)
			{
				// Creates the next set of words to permute
				String tempString = wordInput.substring(0,i); //+ wordInput.substring(i + 1);
				findPermutations(prefix + wordInput.charAt(i), tempString, index);
				System.out.println("The word " + tempString + " has been added to the CollectionOfLetters");
			}
		} // End of recursive case
	} // End of the findPermutation method


} // End of the CollectionOfLetters class
